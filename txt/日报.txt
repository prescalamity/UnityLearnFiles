
今天继续完善了LayaT16项目的动画测试工具，过程中为了确定动画需要配置哪些属性，发现本来res/jsonconfig.json里面应该有动画配置属性的信息，如res/config_res_skill_effect信息，
但文件中却没有。不过之后在文森说的另一个完整的H5的QdazzleDemo项目找到了动画属性配置相关信息。工具最终实现实现效果如下：

记录下在实现过程中遇到一个知识点是Laya在获取目标对象的组件属性内容时，看项目的其它view面板在获取对象组件好像并没有发现用getComponent()接口来获取，
后来搜索了下发现Laya可以在编辑面板中直接设置组件的var属性作为唯一ID，而在脚本中直接申明该组件ID就可以使用了，而在游戏运行时环境中自动关联对象实力，
实现获取目标组件的目的。


================================================================================== 

为了让美术能察看完成的美术资源的在T16项目中的效果，以及设置调节相关动画参数，需要实现一个方便察看的工具面板，在实现过程中主要遇到了两个问题，
一个是在点击播放动画后动画不能居中播放，之后开始看来下Laya的坐标相关资料，本来想通过动画的width属性来计算偏移量，从而设置动画的pivot属性的偏移值来
实现动画居中播放，但测试发现animation的width属性一直是0，之后百度搜索也没发现什么获得动画的对象宽高的方法，问文森说这是要美术根据图片的大小及测试后配置的。
之后先暂时给了合适偏移值测试工具效果。
之后遇到的一个问题是在用laya的ComboBox组件实现一个动画类型下拉框时，发现实现的下拉框在点击之后并没有下拉列表，于是对着Laya官方文档检查代码也没什么问题，
无意间调了下下拉框的位置发现，下拉列表竟然是被背景图挡住了。看起来表头和下拉列表是不在同一渲染层级了，查了下接口也没有修改下拉列表的渲染层级接口，最后还是把
父级容器的渲染层级由10000调成1000才让下拉框正常显示出来，感觉是引擎新创建出来的下拉列表有一个默认的渲染层级。


================================================================================== 

今天主要学习了在T16项目中创建游戏动画对象，并梳理了下动画加载管理类的关系：

在其对象创建过程主要经过操作有：
1、先调用MyAnimation.Rent()接口从对象池中取出一个MyAnimation对象，该接口又通过调用ObjectPool.RentObject()接口进行对象池中对象的创建和取出；
2、设置MyAnimation对象的名字；
3、调用AnimationManager.AnimationLoadRes()接口并传入MyAnimation对象，动画类型，动画图集真实名，回调函数等参数，而在该接口中主要操作有：
     （a）设置MyAnimation对象的相关参数，如动画的中心位置，动画的缩放大小，动画的帧间隔（播放速度），
     （b）将MyAnimation对象在animation_res_pool（动画图集资源池）中注册对应的动画类型和资源名，若没有则新建AnimationResItem进行注册，
     （c）在没有现有注册资源项时，调用Animation.loadAtlas()接口加载动画，在接口设置名字后动画自动缓存，下次根据名字从动画缓存区取出播放即可，
4、动画加载成功后，将动画挂载到stage舞台进行显示；
5、MyAnimation.player()播放
6、使用完后调用MyAnimation.GiveBack()接口归还，该接口先是调用AnimationManager.SubAnimationResCount()取消animation_res_pool的注册，
之后调用ObjectPool.GiveBackObject()将取出的MyAnimation对象重置属性后放回m_idle_key_map（空闲对象池）。

不过在创建时，碰到一个加载的动画对象不存在的报错问题，在dubug测试后发现路径资源路径加载不正确，可能是项目改了文件路径，
修改一下animation_res_config的资源路径即可正确加载动画图集了。不过之后虽然没加载报错，但场景就是就是没有先是目标动画，后来想着可能是渲染顺序问题，
在改动画的zOrder属性后可以在场景正常播放了。



================================================================================== 

今天先是修改了游戏延迟重启的实现方式，不过开始使用lua全局函数传入TimerQuest:AddDelayQuest接口，发现其出现lua函数信息获取错误，
在查看其它对该接口的引用时，发现其传递函数为函数内部的局部函数，之后改成局部函数传递后就可以正常延迟重启游戏了。

之后主要了解LayaAir引擎的基础渲染及Sprite显示类，以下对了解的知识进行大致梳理，首先对于Laya引擎来说，在渲染绘制一个2d图像时主要需要用到Render类，
Stage类，Context类，Sprite类，以及RenderSprite工具类。其类的基本结构如下：

Render类调用Stage类的render方法进行绘制，而Stage类的父类是Sprite类，Sprite类是通过调用RenderSprite类的方法进行绘制。
在Laya引擎中，主要通过Render类进行渲染管理，如创建画布，初始化渲染器，调用stage中的loop函数，元素可见性修改，而Render是一个单例类，并在Laya.init中进行实例化。
对于stage类是放置显示对象的最终容器，并显示游戏元素，只有游戏元素添加到舞台才能被显示。所有的渲染过程也是从Laya.stage开始的，
并在loop帧循环函数进行当前context渲染上下文的渲染和更新逻辑。而在loop中的渲染又是通过调用sprite父类的render()渲染接口进行的。而最终也是调用Context类中的方法
传入renders渲染序列（对应的RenderSprite工具中的不同渲染操作，如位置变化，旋转缩放，透明度变化）进行图像渲染。
其中Sprite为Laya引擎中游戏图片开发的重要元素，是基本的显示图形的显示列表节点。同时sprite作为也可以用来添加多个子节点，以及进行碰撞检测和排版，响应点击事件。


================================================================================== 

今天在整理多语言接口时，遇见了在玩家设置切换语言后，需要延迟一帧进行游戏重启，搜索了解到因为游戏语言是用Unity3d中的PlayerPrefs
进行保存的，而默认Unity 在程序退出时保存参数，所以为确保设置的语言已保存本地而有了延迟一帧重启游戏的需求。一开始打算在引擎的XDevice类中用协程
实现游戏重启时，确保延迟一帧的需求。不过，后来旭军建议最好不要在C#中写，可以在lua中用update实现延迟。为了尽可能保持程序的可扩展性，
方便游戏编译及安装后的功能扩展，能在lua中实现的功能尽量在lua中实现。
之后在通过使用main.lua的Update主循环中添加延迟重启update，以及在延迟重启update计算延迟帧数代码实现了游戏延迟帧数重启的需求，
当调用延迟重启接口时，游戏将根据调用的延迟帧数进行延迟重启。不过，因为之前接触的引擎代码主要 C#，有些固化思维逻辑lua主要为项目编写管理了，
导致把延迟重启接口写在了PlatformLoadingView.lua中，在文森检查后说不要写在PlatformLoadingView.lua中，而应该写在lua_source模块，完善T16引擎模块方便后续 
可以以此为模板，最后将延迟重启接口移到了lua_source/language/language_ctrl模块中。
而在实现游戏资源的多语化接口时，暂时设计实现主要将多语言资源放于同一路径下，然后以名字+语言简称为后缀命名区别，在加载读取多语言资源时，
调用多语言资源接口，传入名字获取资源的完整资源名。



================================================================================== 

今天在学习laya项目动画池管理时，发现动画池的管理有两个池的存在，
一个是由AnimationManager单例模式中的animation_res_pool池，主要存放AnimationResItem对象，另一个为myanimation继承ObjectPool类的m_obj_map池，存放
开始有些不明白为什么动画管理需要两个池，后来问文森说animation_res_pool池主要用来管理图集资源，m_obj_map池则主要用来管理动画对象资源，
而动画对象的卸载并不一定图集资源也要卸载。继续了解发现，对于一些动作较多的角色动画，在打图集时会分开，以免在加载图集时过大，把那些没用到的动作资源都加载进来，
造成资源浪费；而对于一些动作较少的角色，在打包成图集时为减少图集文件资源的占用一般将其打包成一个图集，而此时当图集中的某个动作要销毁时，
因为图集中包含多个角色动作图片资源，所以此时动画所在图集却不一定能卸载该资源，从而导致图集的卸载和动画的卸载是分开管理的，即animation_res_pool主要管理Laya.loader.load
生成的图集资源的加载和卸载，而m_obj_map则主要管理Laya.Animation.loadAtlas生成动画对象。

之后了解了下Laya资源加载 LoaderManager和Loader知识点。https://www.cnblogs.com/chiguozi/p/9602430.html
其中LoaderManager是Laya加载资源的统一入口。此类是单例，且请通过Laya.loader访问。全部队列加载完成，会派发 Event.COMPLETE 完成事件；如果队列中任意一个加载失败，
会派发 Event.ERROR 事件，事件回调参数值为加载出错的资源地址。主要提供：批量加载资源。，多线程，多优先级， 重复过滤（复用缓存），错误重试功能。
而Laya.Loader管理laya的加载器，负责控制加载优先级，加载线程维护与上限上线控制，加载失败后重试等操作。在laya中使用的 Laya.loader.load 是LoaderManager的实例中的load，
而不是Laya.Loader的实例的load。另外，值得注意的是不管加载成功或者失败都会出发COMPLETE事件，调用complete方法。


====================================================================================

1219主要学习laya的帧动画的创建与管理，在laya创建帧动画时，主要由美术组给出主角，npc，怪物等角色的系列动作资源图，
然后导入laya项目laya/model/对应角色名文件夹中，并正常为按动作名+序号取名或加一层角色动作层级文件夹+动作序号，
之后在laya编辑器的编辑模式下设置动作资源图片的属性为打包，
按F10进行打包成atlas文件，一般动画模型打包后的图集文件默认放在bin/res/model文件夹的对应角色下，
对于帧动画的创建和加载，主要通过animation类进行，代码如下；

而项目中对动画的管理，主要由AnimationManager、myanimation和objectpool类进行加载和管理，
在首先由AnimationManager进行资源的加载中，并loadAtlas方法中设置动画资源的缓存名字，使laya引擎自动对动画进行缓存，
并创建不同动画类型（如：技能特效，场景特效，主角，npc怪物等不同）的myanimation对象池于AnimationManager中进行管理。
在播放时，则调用对应myanimation池中的player方法传入创建时设置动的动画名进行播放，以及对池中动画取出Rent和归还GiveBack。


loadAtlas(


====================================================================================

1216主要处理T16加载界面的多语言问题，先是删除了loading.lua文件中多余的字段，并将其分成中文（zh）和英文（en）语言表，
不过在将PlatformLoadingView.lua文件中的字段也做多语言支持时，发现用require、import进行模块导入时会对 " . "进行斜杠“/”处理，
这导致无法导入上一级目录模块问题，其解决方式为在C#脚本中，在目标lua虚拟机中添加上一级目录路径后，lua模块才能加载上一级路径模块或其它非子路径的模块。
之后再通过读取LoadingModule表中的对应语言表数据赋值给对应变量，实现游戏资源加载更新界面的多语言支持。

之后测试了T14项目在引擎网络接口混淆后的问题，其中后台给出的gameApi接口在混淆链接连接时是没有问题的，而api的后台混淆接口在连接数据库错误时会直接返回数据库的
错误信息，导致解码失败，以及连接mobel_config_api混淆接口时会返回html的代码格式，导致解码失败。

====================================================================================

1215日报，先是测试了连接混淆代码在T17项目中在加上开关后是否可以运行，测试表明是可以运行的，如下图所示，
在混淆开关关闭后项目是可以正常运行的。



测试了base64编码加密后相比原文的文本大小改变了多少，而计算表明在该混淆模式下混淆加密后的密文相比原文增加了大约1倍的大小，
其base64的原理主要为：Base64编码要求把3个8位字节（3*8=24）转化为4个6位的字节（4*6=24），之后在6位的前面补两个0，形成8位一个字节的形式。
如果剩下的字符不足3个字节，则用0填充，输出字符使用'='，因此编码后输出的文本末尾可能会出现1或2个'='。所以理论上base64编码后的文本比原文本大8/24=1/3
为了保证所输出的编码位可读字符，Base64制定了一个大小为2^6=64编码表，以便进行统一转换。


而在文本较小时，加上分段时增加的随机key值，导致在文本不大的情况下密文为原文的2倍，而在密文足够大时，导致key值增加的影响越小，在该混淆模式下其比值将越接近4/3.

之后为了获得loading.lua文件中加载模式LoadingModule表中的不同语言表，增加了一个在Tolua中有的获得ulua表中表的接口，



====================================================================================

因为在实现引擎网络混淆时要对连接数据进行加密，于是在百度了解了下当下主要的加密算法状态，
其算法主要性能对比如下：



对比而言，考虑到游戏的强实时性，所以在实现时选择了运行速度快，资源消耗低，安全性也较高的AES加密算法。
实现结果如下：


在上图中，为模拟连接携带的数据内容，将加密后的密文数据分成了随机若干段，组成键值对的形式并按键的字符串排序顺序赋值。




=Build（）============================================================

==BuildLayout（）==========================================================
打包UI面板时，收集图集和icon的依赖关系，并写入lua配置文件，
打包layout的时候导出面板资源映射文件，用于海外多语言，当发行地域不同时加载不同的资源文件。

==BuildFont（）==========================================================
（在字体打包时，未前置做资源版本检测）
当字体不是静态字体时，直接对字体文件打包，否则先检测静态字体文本内容是否有改动，若有改动先更新字体包信息再打包。

==BuildUIAtlas（）==========================================================
图集打包打包时，检测图集版本，提高打包效率，
将图集对应的材质球的shader清空，并将图集对应 的png图片转成无损压缩的webp格式，减少图片体积的同事保证其质量，
保存并刷新资源，
检测图集mat，强制其它人将这个mat文件提交到svn，方便修改图集，创建图集包 。

==BuildIcon（）==========================================================
Icon打包，
对于有无损需求的Icon都进行重新打包，否则检查Icon版本是否改变，若改变则进行重新打包。
并在图片文件打包前先把png格式的Icon转成webp格式再打包。

==BuildDynamic（）==========================================================
当有Dynamic图需求的项目打包，需要先生成Dynamic图的配置lua文件，将动态图片的名称和路径保存在lua表中。
之后Dynamic图的打包同样先检查是否有无损需求，以及版本变化，最后转webp格式后打包。


将Icon创建信息保存/_Resource/Textures/UI/Icon/BuildIconConfig.json文件中，管理已打包Icon的文件，
同样已创建的Dynamic图的创建信息将保存到/_Resource/Textures/UI/Dynamic/BuildDynamicConfig.json文件中。

-----------------------------------------------------------------------------------------------------------------------------------------



T16项目场景资源打包的一般过程和问题方面

=build（）start ============================================================
场景打包前更新shader渲染
场景的预设 ShaderGlobalControl  prefab
场景版本是否更新，打包要判断所有依赖文件的版本号，使资源版本不变的资源，提高打包效率
在打包前判断是否需要重新烘焙场景，合并光照贴图和shadowmask贴图，保存场景修改，
检查并删除场景更新后没用的依赖资源。

==DoScene（）start===========================================================================
（做打包时检查场景的资源是否符合优化，并打包）
检测场景的反射探头模式是否为runtime以及反射探头的数量超出限制的，为runtime则返回false，
删除未激活物体，删除mesh为空的组件，删除非Collider下的组件[Collider]，
物体[" + rd.gameObject.name + "]含有MeshRender组件却没有和MeshFilter配合使用或者材质球为空，将被删除，
场景的结点 中使用的材质使用的shader的名字不包含 Q/Scene, 请检查使用是否合理，
再prefab制作过程中，当删除prefab节点时，可能会产生多余的依赖引用，打包时需清理引擎资源库资源中冗余依赖的prefab资源，
保存场景修改，
调用BuildPipeline.BuildAssetBundles(outputPath, op, EditorUserBuildSettings.activeBuildTarget)接口，打包当前场景资源到
项目的Application.dataPath/StreamingAssets下的对应目录中。
删除在创建场景中临时创建的过度预设和文件资源。
==DoScene（）end===========================================================================

==BuildSceneBundle（）start==============================================================
将打包后的场景大小信息通过wwwfrom和www类在update中上传只服务器，监控场景版本的异常。
删除项目StreamingAssets路径下的就的场景资源信息，优化内存资源。
将打包的场景版本名字信息保存到项目Application.dataPath + "/../abNameForScene.json"文件中，以便打包场景版本和AB包进行管理
==BuildSceneBundle（）end==============================================================

==GenerateAllSceneEffectConfig()  start============================================================
生成场景特效信息（包括特效名字、AOI同步类型、hash值、特效等级、场景位置、旋转、大小）的lua配置文件，
并保存到luaPath + "/config/sceneinfo/effects/effect_info_{0}.lua"， 以便通过lua脚本对场景特效进行控制。
==GenerateAllSceneEffectConfig()  end============================================================

=build（）end ============================================================






























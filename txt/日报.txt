
因为在实现引擎网络混淆时要对连接数据进行加密，于是在百度了解了下当下主要的加密算法状态，
其算法主要性能对比如下：



对比而言，考虑到游戏的强实时性，所以在实现时选择了运行速度快，资源消耗低，安全性也较高的AES加密算法。
实现结果如下：


在上图中，为模拟连接携带的数据内容，将加密后的密文数据分成了随机若干段，组成键值对的形式并按键的字符串排序顺序赋值。




=Build（）============================================================

==BuildLayout（）==========================================================
打包UI面板时，收集图集和icon的依赖关系，并写入lua配置文件，
打包layout的时候导出面板资源映射文件，用于海外多语言，当发行地域不同时加载不同的资源文件。

==BuildFont（）==========================================================
（在字体打包时，未前置做资源版本检测）
当字体不是静态字体时，直接对字体文件打包，否则先检测静态字体文本内容是否有改动，若有改动先更新字体包信息再打包。

==BuildUIAtlas（）==========================================================
图集打包打包时，检测图集版本，提高打包效率，
将图集对应的材质球的shader清空，并将图集对应 的png图片转成无损压缩的webp格式，减少图片体积的同事保证其质量，
保存并刷新资源，
检测图集mat，强制其它人将这个mat文件提交到svn，方便修改图集，创建图集包 。

==BuildIcon（）==========================================================
Icon打包，
对于有无损需求的Icon都进行重新打包，否则检查Icon版本是否改变，若改变则进行重新打包。
并在图片文件打包前先把png格式的Icon转成webp格式再打包。

==BuildDynamic（）==========================================================
当有Dynamic图需求的项目打包，需要先生成Dynamic图的配置lua文件，将动态图片的名称和路径保存在lua表中。
之后Dynamic图的打包同样先检查是否有无损需求，以及版本变化，最后转webp格式后打包。


将Icon创建信息保存/_Resource/Textures/UI/Icon/BuildIconConfig.json文件中，管理已打包Icon的文件，
同样已创建的Dynamic图的创建信息将保存到/_Resource/Textures/UI/Dynamic/BuildDynamicConfig.json文件中。

-----------------------------------------------------------------------------------------------------------------------------------------



T16项目场景资源打包的一般过程和问题方面

=build（）start ============================================================
场景打包前更新shader渲染
场景的预设 ShaderGlobalControl  prefab
场景版本是否更新，打包要判断所有依赖文件的版本号，使资源版本不变的资源，提高打包效率
在打包前判断是否需要重新烘焙场景，合并光照贴图和shadowmask贴图，保存场景修改，
检查并删除场景更新后没用的依赖资源。

==DoScene（）start===========================================================================
（做打包时检查场景的资源是否符合优化，并打包）
检测场景的反射探头模式是否为runtime以及反射探头的数量超出限制的，为runtime则返回false，
删除未激活物体，删除mesh为空的组件，删除非Collider下的组件[Collider]，
物体[" + rd.gameObject.name + "]含有MeshRender组件却没有和MeshFilter配合使用或者材质球为空，将被删除，
场景的结点 中使用的材质使用的shader的名字不包含 Q/Scene, 请检查使用是否合理，
再prefab制作过程中，当删除prefab节点时，可能会产生多余的依赖引用，打包时需清理引擎资源库资源中冗余依赖的prefab资源，
保存场景修改，
调用BuildPipeline.BuildAssetBundles(outputPath, op, EditorUserBuildSettings.activeBuildTarget)接口，打包当前场景资源到
项目的Application.dataPath/StreamingAssets下的对应目录中。
删除在创建场景中临时创建的过度预设和文件资源。
==DoScene（）end===========================================================================

==BuildSceneBundle（）start==============================================================
将打包后的场景大小信息通过wwwfrom和www类在update中上传只服务器，监控场景版本的异常。
删除项目StreamingAssets路径下的就的场景资源信息，优化内存资源。
将打包的场景版本名字信息保存到项目Application.dataPath + "/../abNameForScene.json"文件中，以便打包场景版本和AB包进行管理
==BuildSceneBundle（）end==============================================================

==GenerateAllSceneEffectConfig()  start============================================================
生成场景特效信息（包括特效名字、AOI同步类型、hash值、特效等级、场景位置、旋转、大小）的lua配置文件，
并保存到luaPath + "/config/sceneinfo/effects/effect_info_{0}.lua"， 以便通过lua脚本对场景特效进行控制。
==GenerateAllSceneEffectConfig()  end============================================================

=build（）end ============================================================
































0328周报

先是修改网络混淆中用post方式进行二进制传输时，后台接收的二进制数据会混有非加密的数据，导致后台用Aes解密时无法解密。经测试得，因为原代码的表单是使用的是unity的WWWForm表单，
该表单可以同时发送二进制数据与UTF8编码的数据。但在使用WWWForm表单传输数据时，表单中的data是经过格式化的数据。即后台接收的二进制数据转化成UTF8编码时，之前的的UFT8编码的
key value键值数据之间会加“=”“&”进行分隔，而二进制之间的数据会使用前后标识符进行格式话。
如此，后台接收到的二进制数据便混有加密和非加密的二进制数据，导致直接转UTF8会乱码，而用Aes解码又报错。了解原因后，改了下unity工程中C#的post发送代码，将发送加密的二进制数据
使用自建加密表单进行发送。遇到个小bug就是使用自建表单的http链接直接报错，无法发出，查了下网上案例并在文森的提醒下发现是数据发送的长度没改过来，还是原来混乱数据的长度，请求一直等待输入。
改了后，后台便能正常接收纯加密的二进制数据并正确解密了。

之后内网测试，报出礼包码兑换错误和游戏部分模块加载不出。查游戏log发现礼包码兑换错误是因为后台没有混淆礼包码兑换接口导致的，在后台加密混淆接口后兑换正常。而游戏模块加载不出看log是
lua资源加载报错，和项目组讨论后，重新打包安卓资源测试，游戏帮派，邮件，家族，兑换码，boss，活动等各部分运行正常。

再之后是游戏外网打包测试，相较与内网，外网的环境更加复杂，问题就更多了。开始游戏不走mobileconfig导致网络通信没有混淆，而把时间跳到混淆时间开关之后时，游戏报错网络超时错误。
游戏连网络通信都不能进行了，作为联网的游戏自然也进不去。为解决这个问题，晓明使用网络抓包工具抓取游戏网络请求发出和返回的状态。分析数据发现访问的链接返回302状态，即访问的服务器资源
已经临时转移了，需要重定向。而此时系统认为这可能是危险链接并对其屏蔽，导致链接通信失败。而在后台不进行资源跳转设置后需要网络通信便可以进行了。
不过，虽然网络可以通信，但游戏还是进不去，继续看log。显示客户端是可以接收到后台发送的二进制数据的，只是不能正常解密。而这在内网通信正常的情况下说明前后台的Aes加密解密是功能没有问题的，
最有可能就想前面遇见的接收的二进制数据是混杂的，有非加密和加密数据。将该二进制对应的Base64进行在线转码发现，后台发送的二进制数据确实混有非加密和加密数据。反馈后台将非加密的日志数据
取出游戏客户端便可以正常解密了。
此时游戏客户端虽然可以正常解密，但还是进不去。其原因是虽然解密不报错了，但解密出来的数据并不是明文数据，而是用之前Base64分段方式加密的密文数据。继续反馈后台，查找结果是
因为链接进行了二次跳转，代理层返回的数据已经进行Base64分段加密，之后后台再进行Aes加密，导致客户端Aes解密出来的是Base64密文。最后，后台返回只用Aes加密的数据后，游戏客户端终于能
进入游戏了。

一波三折啊，从这事可以看出，游戏（程序）log千万千万别省，尤其是关键的游戏log。好的游戏log可以在查找游戏问题时，极大减少问题的解决成本。

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

而关于2019工程Lua进入游戏主界面，主要看了并调试工程lua进入游戏登录即场景物体加载的代码， 以实现修改代码在玩家点击进入游戏按钮后，游戏切换状态加载主UI界面。
不过，过程中因为当前工程还没有主UI界面，于是从T16工程中，搬运了有关素材，并仿照T16的NGUI主界面在2019工程中用UGUI也做了一个。期间了解了下，叶坤做的unity资源导入时，
自动根据资源路径类型设置资源的格式。


=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=

0321周报

对于cocos2d序列学习了下书中第三章的知识，了解游戏渲染作为游戏一帧中后期输出给玩家部分所涉及的一些基本概念（如：顶点着色器，图元装配，光栅化，片段着色器，片段测试），
和OpenGL渲染流程中各阶段所要做的事情，以及为避免玩家体验到画面图元被逐个渲染出来的糟糕体验而设置前后双缓冲区来优化的策略。

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

关于 Unity2019工程完善lua模块，实现登录并进入游戏主UI界面，先是配置了Unity2019的环境并梳理了下项目中游戏状态的切换，梳理流程图如下：



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

而关于网络混淆，根据项目要求、相关讨论和加密实验测试，决定使用Aes加密算法对游戏数据在网络传输时进行加密，以取代之前用Base64+打乱排序顺序的策略进行网络混淆。且对于加密后的游戏数据直接用
二进制数据进行网络传输。
（AES和RSA加密耗时测试结果图）


经过和后台文建联调，首先C#实现的Aes加密算与php实现的Aes加密算法是可以互相加密解密的。
（后台Aes解密结果）

其次，在实现过程中，发现项目的网络http模块代码不够完善。因为之前传的是UTF8的编码数据转成的二进制数据，所以在客户端接收到的二进制数据直接转成UTF8编码数据并使用是没有问题的。
但当传输的不是UTF8格式的编码转成的二进制数据时（如：加密后生成的二进制数据），再将该二进制数据转成UFT8使用就出现问题了。
因为由于UTF8编码特性 （当UTF8编码不能识别二进制数据时，转码UTF8将会被“？”代替），所以对于非UTF8转成的二进制数据强制转UTF8编码是不可逆的，即乱码的UTF8转二进制数据和原本的二进制数据
是不一样的。
所以用加密后的二进制数据在网络中传输时，解密必须用客户端接收到的原二进制数据进行解密，而不能先转UFT8编码格式。 

最后，遇到个问题就是.net在post方式传输表单数据时，如果数据为正常编码数据，.net会格式话键值数据并在每个键值之间加上“&”符号；而如果为二进制数据时，会在二进制数据前加上一些表示内容，
这样导致后台接收的主体二进制数据是UTF8和加密混合成的，需要后台区分二进制数据的.net的UTF8部分（该部分可以直接转UTF8）和游戏数据加密部分（该部分要先解码在转UTF8）。


=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=

0314周报

读了下我所理解的cocos2dx的第二章，了解了cocos2d引擎的基本架构，如使用资源引用计数来进行内存资源管理，通过UI遍历对游戏对象进行管理、坐标变换、渲染顺序制定，游戏循环驱动游戏实时动态更新，
以及用异步加载资源来减轻游戏主线程负担，提高游戏性能。

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

在做3dLogic build dll unity版本优化时，为了统一3dLogic 和打包机中安装的unity版本，需要在sh打包脚本增加unity版本检测并将与打包机版本不同的3dLogic项目替换为相同版本。过程先是
熟悉了下项目脚本打包代码，定位将unity版本检测与替换代码增加到buildX3dlogic.sh打包脚本。
不过在编写代码时，因为之前对sh脚本编的少，就一个查找替换的简单功能都在网上好找了一番。尤其过程中，因为一开始是在window下装的shell编译环境，将代码编号后放在mac系统中运行却怎么都报错，
命令参数不符合要求。（当然，s与window终端的命令差异就更大了）
如命令：sed -i  "s/Applications.*Unity\.app/Applications\/unityVerGame\/Unity\.app/g"  xxx.file    //将xxx.file文件中的“Applications.*Unity.app”文本替换为“Applications/unityVerGame/Unity.app”
该命令在window的shell环境是正常运行的，但在mac系统中却报错。问了下文森说，linux 的shell命令和mac的shell是有区别的，像上面的命令在mac的shell中就需要在 -i 之后加上一对引号，来指定备份格式，
如果不需要备份，引号里的内容可以为空。
即在mac中改为：sed -i '' "s/Applications.*Unity\.app/Applications\/unityVerGame\/Unity\.app/g"  xxx.file

之后在网上了解到，因为macOS和linux内核不同导致shell命令还是有差别的。（https://blog.csdn.net/weixin_42672054/article/details/81298506）
macOS 内核被官方称为 XNU（即“XNU is Not Unix”）。根据 苹果公司的 Github 页面，XNU 是“将卡耐基梅隆大学开发的 Mach 内核和 FreeBSD 组件整合而成的混合内核，加上用于
编写驱动程序的 C++ API”。代码的 BSD 子系统部分“在微内核系统中通常实现为用户空间的服务”。Mach 部分负责底层工作，例如多任务、内存保护、虚拟内存管理、内核调试支持和控制台 I/O。
Linux 内核的特性，虽然 macOS 内核结合了微内核（Mach）和宏内核（BSD）的特性，但 Linux 只是一个宏内核。宏内核负责管理 CPU、内存、进程间通信、设备驱动程序、文件系统和系统服务调用。

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

在做h2使用基础库任务时，替换本身倒是没什么难度，就是将baselib库打包成Android的aar，之后逐个查找对比，h2项目中的class或使用接口与基础库中的class或接口进行比较，将h2中与基础相同的类或
接口删除，然后在项目用到删除的class或接口时就引用基础库中的class或接口即可。当然，在对比时，除了实现h2使用基础库外，根据h2中写的接口差异，也优化扩展了下基础库的class和接口实现。
如，在基础库的视频暂停接口中增加了，停止后回调功能。
不过，在验证修改的接口功能时，遇到了个麻烦。就是本来想在h2项目修改编译后，在Android环境中测试下接口功能，一开始用手机浏览器访问h2的项目地址，西行记游戏可以正常进行，但返回的结果错误。
甚至按代码中的log文件位置找游戏log位置都找不到。还是问了下文森才知道，游戏是推app，直接在手机浏览器中访问有些功能是不能实现的。之后安装app运行后接口测试正常，也能找到游戏log文件。

那为什么游戏不推手机浏览器版呢，玩家都不用安装app只要一个链接就可以啊？
目前得到结论是，相比安装app游戏，手机浏览器链接版游戏对硬件的使用上肯定是比不上安装app游戏的，自然安装app游戏能获得更好的游戏体验。

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

而关于h2翻译整理文档，和项目组富华讨论了下，目前h2项目的多语言翻译还没有开始，计划使用T16的多语言实现方式，将需要多语言处理的字段和资源提取处理，放在以多语言路径为区别的文件夹下，
之后在代码中增加游戏语言判断来获取对应路径下的资源。



=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=

0307周报，关于T16攻速性能问题，和项目组讨论使用摊帧进行优化，首先少飞说数据线的计算优化，结论是不行的，如果在更新游戏数据使用摊帧优化的话，要修改游戏战斗实现方式非常麻烦，
而且后续推行用laya不用u3d端了，做这个没意义了，实际玩家很少能玩到攻速很快的情况。

为了确定玩家真实的后期游戏性能情况，和凯宁测试了下：根据策划计算，协同模式理论上，每合成一个7星需要64个1星，召唤64次，一共需要20150sp，要到34关才可以获得这么多sp。
所以，如果队伍里没有升星的英雄，多召唤的英雄，加sp的英雄的话，需要到34关才集齐一个七星英雄的资源。

而协同模式玩家通关，后期非主流组合一般到30左右，主流队伍一般能到50~70回合左右（配合差的50左右，配合好的70左右）。使用最理想的队伍（队伍里有升星，多召唤，加sp的英雄），
配合好，加一定运气可以过100回合左右及以上。而场上英雄星数后期1~7星都可能有，其中7星英雄两边加起来一般4-7个左右。（理论上70回合一供可获得72000sp，约3.6个7星英雄）。

性能方面，使用4G运行内存配置的手机，测了几组卡牌组合，其中对于没有升星，多召唤，加sp的英雄的组合，一般过10几关就结束了，而运气好点能到30几关，此时游戏帧率一般在25~30左右
性能还算稳定。而在有升星，多召唤，加sp的英雄的组合，加上玩家配合好时，在游戏后期（按70回合算）观察结果，帧率普遍在22帧以上，每回合有1到2帧在20帧一下，
游戏表现看画面还算流畅，没有明显的卡顿。

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

关于H2项目android和ios提供多语言获取语言支持接口，主要过程为将从Unity的（Android、iOS）baselib多语言代码同步到H5的（Android、iOS）baselib，其过程中学习了H5和Android、ios的交互问题。
在JS与AndroidJava的交互中，主要原理如下图所示，

在H5项目中，PlatformSDK模块使用PlatformClass.createClass("com.qdazzleh5.JSBridge")接口来创建一个Java的JSBridge脚本代理，在H5使用时传入Java中的函数名（如，"CallPlatformFunc"函数），
以及字符参数（在多参数时使用Json字符参数）。

在Android的Java方面，将写好的游戏语言获取与保存接口托管到PlatformInterfaceDelegation对象中，并注册到PlatformInterfaceManager单例。而JSBridge类则通过
PlatformInterfaceManager.Inctance().CallPlatformFunc()接口调用注册到PlatformInterfaceManager单例中的目标函数。

同样，当平台为iOS时，H5中的PlatformSDK模块也会创建一个OC的JSBridge脚本代理，在OC的JSBridge中，将要调用的目标函数在InitCallPlatform函数中进行注册，在H5调用OC的
JSBridge.CallPlatformFunc接口时，将运行传入（Json化的）参数中对应的已注册目标函数。

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

之后继续看了下T16项目的模型打包代码，为减少网络传输资源大小和资源数量等需求，需要对unity中的项目资源（如：模型，特效，ui，场景，声音，shader等）进行AssetBundle打包，
且打包后资源大小不会增加。
如，对于模型打包主要通过ModelBundleTool模块进行，实现项目中的Assets/_Resources/model下的模型资源进行整体或指定单个打包，并将打包后的bundle放于StreamingAssets/assetbundle
路径下的对应平台中。实现时主要考虑将依赖的公共资源打成一个包减少打包后模型资源，以及在全打包时对于没有改变的模型资源不进行打包以提高打包效率。
主要代码实现：
Init()    {                       初始化相关数据列表
      SrcDir                    设置项目要打包的模型资源位置
      m_NeedRebuild     清空需要重打包模型列表
}

Build()                   打包游戏资源

CheckVersion()      检查资源版本，将需要重新打包的资源加入m_NeedRebuild列表

BuildBundle()         将模型公共资源和个例资源分开打包

CreateCommonResBundle()  创建公共资源包

CreateBundleForFile()           根据模型动画，皮肤，骨骼等类型分别打包

CreateMutilSkinnedMeshBundle(fbxPath, typeDir)        换装模型打包，多skinnedmeshrender 模型打包

CreateSingleSkinnedMeshBundle(fbxPath, typeDir)       单皮肤模型打包

CreateFashionPartBundle(fbxPath, typeDir)                   模型武器 等 换装资源打包

CreateItemBundle(fbxPath, typeDir)                              收集物模型打包，有动画，或没有动画

CreatePrefabBundle()                                                    创建预设体模型打包

GenerateModelConfig()                                                生成模型lua配置文件，保存目标模型的名字，预设，骨骼，动画，部件等属性信息





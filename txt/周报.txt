
0321周报

对于cocos2d序列学习了下书中第三章的知识，了解游戏渲染作为游戏一帧中后期输出给玩家部分所涉及的一些基本概念（如：顶点着色器，图元装配，光栅化，片段着色器，片段测试），
和OpenGL渲染流程中各阶段所要做的事情，以及为避免玩家体验到画面图元被逐个渲染出来的糟糕体验而设置前后双缓冲区来优化的策略。

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

关于 Unity2019工程完善lua模块，实现登录并进入游戏主UI界面，先是配置了Unity2019的环境并梳理了下项目中游戏状态的切换，梳理流程图如下：



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

而关于网络混淆，根据项目要求、相关讨论和加密实验测试，决定使用Aes加密算法对游戏数据在网络传输时进行加密，以取代之前用Base64+打乱排序顺序的策略进行网络混淆。且对于加密后的游戏数据直接用
二进制数据进行网络传输。
（AES和RSA加密耗时测试结果图）


经过和后台文建联调，首先C#实现的Aes加密算与php实现的Aes加密算法是可以互相加密解密的。
（后台Aes解密结果）

其次，在实现过程中，发现项目的网络http模块代码不够完善。因为之前传的是UTF8的编码数据转成的二进制数据，所以在客户端接收到的二进制数据直接转成UTF8编码数据并使用是没有问题的。
但当传输的不是UTF8格式的编码转成的二进制数据时（如：加密后生成的二进制数据），再将该二进制数据转成UFT8使用就出现问题了。
因为由于UTF8编码特性 （当UTF8编码不能识别二进制数据时，转码UTF8将会被“？”代替），所以对于非UTF8转成的二进制数据强制转UTF8编码是不可逆的，即乱码的UTF8转二进制数据和原本的二进制数据
是不一样的。
所以用加密后的二进制数据在网络中传输时，解密必须用客户端接收到的原二进制数据进行解密，而不能先转UFT8编码格式。 

最后，遇到个问题就是.net在post方式传输表单数据时，如果数据为正常编码数据，.net会格式话键值数据并在每个键值之间加上“&”符号；而如果为二进制数据时，会在二进制数据前加上一些表示内容，
这样导致后台接收的主体二进制数据是UTF8和加密混合成的，需要后台区分二进制数据的.net的UTF8部分（该部分可以直接转UTF8）和游戏数据加密部分（该部分要先解码在转UTF8）。


=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=

0314周报

读了下我所理解的cocos2dx的第二章，了解了cocos2d引擎的基本架构，如使用资源引用计数来进行内存资源管理，通过UI遍历对游戏对象进行管理、坐标变换、渲染顺序制定，游戏循环驱动游戏实时动态更新，
以及用异步加载资源来减轻游戏主线程负担，提高游戏性能。

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

在做3dLogic build dll unity版本优化时，为了统一3dLogic 和打包机中安装的unity版本，需要在sh打包脚本增加unity版本检测并将与打包机版本不同的3dLogic项目替换为相同版本。过程先是
熟悉了下项目脚本打包代码，定位将unity版本检测与替换代码增加到buildX3dlogic.sh打包脚本。
不过在编写代码时，因为之前对sh脚本编的少，就一个查找替换的简单功能都在网上好找了一番。尤其过程中，因为一开始是在window下装的shell编译环境，将代码编号后放在mac系统中运行却怎么都报错，
命令参数不符合要求。（当然，s与window终端的命令差异就更大了）
如命令：sed -i  "s/Applications.*Unity\.app/Applications\/unityVerGame\/Unity\.app/g"  xxx.file    //将xxx.file文件中的“Applications.*Unity.app”文本替换为“Applications/unityVerGame/Unity.app”
该命令在window的shell环境是正常运行的，但在mac系统中却报错。问了下文森说，linux 的shell命令和mac的shell是有区别的，像上面的命令在mac的shell中就需要在 -i 之后加上一对引号，来指定备份格式，
如果不需要备份，引号里的内容可以为空。
即在mac中改为：sed -i '' "s/Applications.*Unity\.app/Applications\/unityVerGame\/Unity\.app/g"  xxx.file

之后在网上了解到，因为macOS和linux内核不同导致shell命令还是有差别的。（https://blog.csdn.net/weixin_42672054/article/details/81298506）
macOS 内核被官方称为 XNU（即“XNU is Not Unix”）。根据 苹果公司的 Github 页面，XNU 是“将卡耐基梅隆大学开发的 Mach 内核和 FreeBSD 组件整合而成的混合内核，加上用于
编写驱动程序的 C++ API”。代码的 BSD 子系统部分“在微内核系统中通常实现为用户空间的服务”。Mach 部分负责底层工作，例如多任务、内存保护、虚拟内存管理、内核调试支持和控制台 I/O。
Linux 内核的特性，虽然 macOS 内核结合了微内核（Mach）和宏内核（BSD）的特性，但 Linux 只是一个宏内核。宏内核负责管理 CPU、内存、进程间通信、设备驱动程序、文件系统和系统服务调用。

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

在做h2使用基础库任务时，替换本身倒是没什么难度，就是将baselib库打包成Android的aar，之后逐个查找对比，h2项目中的class或使用接口与基础库中的class或接口进行比较，将h2中与基础相同的类或
接口删除，然后在项目用到删除的class或接口时就引用基础库中的class或接口即可。当然，在对比时，除了实现h2使用基础库外，根据h2中写的接口差异，也优化扩展了下基础库的class和接口实现。
如，在基础库的视频暂停接口中增加了，停止后回调功能。
不过，在验证修改的接口功能时，遇到了个麻烦。就是本来想在h2项目修改编译后，在Android环境中测试下接口功能，一开始用手机浏览器访问h2的项目地址，西行记游戏可以正常进行，但返回的结果错误。
甚至按代码中的log文件位置找游戏log位置都找不到。还是问了下文森才知道，游戏是推app，直接在手机浏览器中访问有些功能是不能实现的。之后安装app运行后接口测试正常，也能找到游戏log文件。

那为什么游戏不推手机浏览器版呢，玩家都不用安装app只要一个链接就可以啊？
目前得到结论是，相比安装app游戏，手机浏览器链接版游戏对硬件的使用上肯定是比不上安装app游戏的，自然安装app游戏能获得更好的游戏体验。

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

而关于h2翻译整理文档，和项目组富华讨论了下，目前h2项目的多语言翻译还没有开始，计划使用T16的多语言实现方式，将需要多语言处理的字段和资源提取处理，放在以多语言路径为区别的文件夹下，
之后在代码中增加游戏语言判断来获取对应路径下的资源。



=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=

0307周报，关于T16攻速性能问题，和项目组讨论使用摊帧进行优化，首先少飞说数据线的计算优化，结论是不行的，如果在更新游戏数据使用摊帧优化的话，要修改游戏战斗实现方式非常麻烦，
而且后续推行用laya不用u3d端了，做这个没意义了，实际玩家很少能玩到攻速很快的情况。

为了确定玩家真实的后期游戏性能情况，和凯宁测试了下：根据策划计算，协同模式理论上，每合成一个7星需要64个1星，召唤64次，一共需要20150sp，要到34关才可以获得这么多sp。
所以，如果队伍里没有升星的英雄，多召唤的英雄，加sp的英雄的话，需要到34关才集齐一个七星英雄的资源。

而协同模式玩家通关，后期非主流组合一般到30左右，主流队伍一般能到50~70回合左右（配合差的50左右，配合好的70左右）。使用最理想的队伍（队伍里有升星，多召唤，加sp的英雄），
配合好，加一定运气可以过100回合左右及以上。而场上英雄星数后期1~7星都可能有，其中7星英雄两边加起来一般4-7个左右。（理论上70回合一供可获得72000sp，约3.6个7星英雄）。

性能方面，使用4G运行内存配置的手机，测了几组卡牌组合，其中对于没有升星，多召唤，加sp的英雄的组合，一般过10几关就结束了，而运气好点能到30几关，此时游戏帧率一般在25~30左右
性能还算稳定。而在有升星，多召唤，加sp的英雄的组合，加上玩家配合好时，在游戏后期（按70回合算）观察结果，帧率普遍在22帧以上，每回合有1到2帧在20帧一下，
游戏表现看画面还算流畅，没有明显的卡顿。

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

关于H2项目android和ios提供多语言获取语言支持接口，主要过程为将从Unity的（Android、iOS）baselib多语言代码同步到H5的（Android、iOS）baselib，其过程中学习了H5和Android、ios的交互问题。
在JS与AndroidJava的交互中，主要原理如下图所示，

在H5项目中，PlatformSDK模块使用PlatformClass.createClass("com.qdazzleh5.JSBridge")接口来创建一个Java的JSBridge脚本代理，在H5使用时传入Java中的函数名（如，"CallPlatformFunc"函数），
以及字符参数（在多参数时使用Json字符参数）。

在Android的Java方面，将写好的游戏语言获取与保存接口托管到PlatformInterfaceDelegation对象中，并注册到PlatformInterfaceManager单例。而JSBridge类则通过
PlatformInterfaceManager.Inctance().CallPlatformFunc()接口调用注册到PlatformInterfaceManager单例中的目标函数。

同样，当平台为iOS时，H5中的PlatformSDK模块也会创建一个OC的JSBridge脚本代理，在OC的JSBridge中，将要调用的目标函数在InitCallPlatform函数中进行注册，在H5调用OC的
JSBridge.CallPlatformFunc接口时，将运行传入（Json化的）参数中对应的已注册目标函数。

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

之后继续看了下T16项目的模型打包代码，为减少网络传输资源大小和资源数量等需求，需要对unity中的项目资源（如：模型，特效，ui，场景，声音，shader等）进行AssetBundle打包，
且打包后资源大小不会增加。
如，对于模型打包主要通过ModelBundleTool模块进行，实现项目中的Assets/_Resources/model下的模型资源进行整体或指定单个打包，并将打包后的bundle放于StreamingAssets/assetbundle
路径下的对应平台中。实现时主要考虑将依赖的公共资源打成一个包减少打包后模型资源，以及在全打包时对于没有改变的模型资源不进行打包以提高打包效率。
主要代码实现：
Init()    {                       初始化相关数据列表
      SrcDir                    设置项目要打包的模型资源位置
      m_NeedRebuild     清空需要重打包模型列表
}

Build()                   打包游戏资源

CheckVersion()      检查资源版本，将需要重新打包的资源加入m_NeedRebuild列表

BuildBundle()         将模型公共资源和个例资源分开打包

CreateCommonResBundle()  创建公共资源包

CreateBundleForFile()           根据模型动画，皮肤，骨骼等类型分别打包

CreateMutilSkinnedMeshBundle(fbxPath, typeDir)        换装模型打包，多skinnedmeshrender 模型打包

CreateSingleSkinnedMeshBundle(fbxPath, typeDir)       单皮肤模型打包

CreateFashionPartBundle(fbxPath, typeDir)                   模型武器 等 换装资源打包

CreateItemBundle(fbxPath, typeDir)                              收集物模型打包，有动画，或没有动画

CreatePrefabBundle()                                                    创建预设体模型打包

GenerateModelConfig()                                                生成模型lua配置文件，保存目标模型的名字，预设，骨骼，动画，部件等属性信息




